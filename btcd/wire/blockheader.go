// Copyright (c) 2013-2016 The btcsuite developers
// Copyright (c) 2018-2021 The Omegasuite developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package wire

import (
	"bytes"
	"io"
	"time"

	"github.com/omegasuite/btcd/chaincfg/chainhash"
	"github.com/omegasuite/btcd/wire/common"
)

const (
	CommitteeSize = 3
	CommitteeSigs = 2  // signature required for a signed block. just over half, can't be higher
	POWRotate     = 2  // rotation upon a POW block
	MinerGap      = 3  // a miner must wait between to candidacies. should >= CommitteeSize - 1
	MaxTPSReports = 10 // max number of tps reports in a block
	MinTPSReports = 3  // min number of tps reports in a block

	TimeGap = 5 // time gap between two signed blocks generated by the same miner,
	// when txs in mem. pool is less than 1/2 of max block txs.
	// also 1/2 of time to wait before generate a pow block
	MINER_RORATE_FREQ          = 200 // rotate committee every MINER_RORATE_FREQ block
	DESIRABLE_MINER_CANDIDATES = 40  // the desirable number of miner candidate we want to have
	SCALEFACTORCAP             = 48
	DifficultyRatio            = 4 // ratio of difficulty for tx chain and miner chain

	Version2 = 0x20000
	Version3 = 0x30000
	Version4 = 0x40000
	Version5 = 0x50000
	Version6 = 0x60000
)

// current code version
// version (in block) is a uint32, consists of 2 parts:
// high 16 bits is a odd number increases with each code revision
// low 16 bits is for version bits scheme to be voted on.
var CodeVersion = uint32(Version5) // current version of code.

// MaxBlockHeaderPayload is the maximum number of bytes a block header can be.
// Version 4 bytes + Timestamp 4 bytes + Bits 4 bytes + Nonce 4 bytes +
// PrevBlock and MerkleRoot hashes.
//const MaxBlockHeaderPayload = 16 + (chainhash.HashSize * 2)
const MaxBlockHeaderPayload = 24 + (chainhash.HashSize * 2)
const MaxMinerBlockHeaderPayload = 5000

type Violations struct {
	// Violation report formatï¼š
	Height  int32            // Height of Tx blocks
	MRBlock chainhash.Hash   // the MR block of violator
	Blocks  []chainhash.Hash // the double signed TX blocks
}

func (b *Violations) Read(r io.Reader) error {
	if err := common.ReadElement(r, &b.Height); err != nil {
		return nil
	}
	if b.Height == 0 {
		return nil
	}
	if err := common.ReadElement(r, &b.MRBlock); err != nil {
		return err
	}

	var signed int32
	if t, err := common.ReadVarInt(r, 0); err != nil {
		return err
	} else {
		signed = int32(t)
	}

	b.Blocks = make([]chainhash.Hash, signed)
	for i := int32(0); i < signed; i++ {
		if err := common.ReadElement(r, &b.Blocks[i]); err != nil {
			return err
		}
	}

	return nil
}

func (b *Violations) Write(w io.Writer) error {
	if b.Height == 0 {
		return nil
	}
	if err := common.WriteElement(w, b.Height); err != nil {
		return err
	}
	var signed = int32(len(b.Blocks))
	if err := common.WriteElement(w, b.MRBlock); err != nil {
		return err
	}
	if err := common.WriteVarInt(w, 0, uint64(signed)); err != nil {
		return err
	}
	for i := int32(0); i < signed; i++ {
		if err := common.WriteElement(w, b.Blocks[i]); err != nil {
			return err
		}
	}

	return nil
}

// we use a dual block chain structure. one is Tx chain (normal block chain), one is committee candidate chain
// MingingRightBlock is miner candidate chain struct
type MingingRightBlock struct {
	// Version of the block. This is not the same as the protocol version.
	Version uint32

	// Hash of the previous MingingRightBlock block in the block chain.
	PrevBlock chainhash.Hash

	// The best main chain block known to the miner. Must not be before the BestBlock of the previous MingingRightBlock.
	BestBlock chainhash.Hash

	Timestamp time.Time

	// Difficulty target
	Bits uint32

	// Nonce used to generate the Miner,
	Nonce int32

	// new committee member.
	Miner [20]byte // address (pubkey hash) of new member for next committee

	Connection []byte	// connection info. either an IP:port address or an RSA pubkey

	// Min Collateral required for the next block. ver. 0x20000
	Collateral uint32	// Collateral required for the next block
	MeanTPH	uint32		// average TPH = (63 * prev MeanTPH + averga TPH of this block) / 64

	Utxos 	*OutPoint		  // Collateral provided by the miner.

	ViolationReport []*Violations // the double signers and proof
	TphReports      []uint32     // report of TPS of preceeing miners
	ContractLimit	int64		// alternative contract execution limit
}

// difficulty target for new node submission is 1 min.
// committee generate a block every 3 sec. (target time)
// MINER_RORATE_FREQ is 40 blocks

// a POW block must have upto DefaultCommitteeSize - 1 nominees in its coinbase (i.e., in output's PKscript with output amount of 0)
// under following priority rule: all the NewNode in the POW block immediately preceding this block, The miner candidate.

// BlockHeader defines information about a block and is used in the bitcoin
// block (MsgBlock) and headers (MsgHeaders) messages.
type BlockHeader struct {
	// Version of the block.  This is not the same as the protocol version.
	Version uint32

	// Hash of the previous block header in the block chain.
	PrevBlock chainhash.Hash

	// Merkle tree reference the hash of all transactions for the block.
	MerkleRoot chainhash.Hash

	// Time the block was created.  This is, unfortunately, encoded as a
	// uint32 on the wire and therefore is limited to 2106.
	Timestamp time.Time

	// ContractExec the exact number of VM steps taken to execute all contracts (not including signature validation)
	// This is set by this block's miner, and verified by those who accept the block. The purpose is to prevent
	// spammer who sends out block containing never ending contracts. It is up to each miner to decide the max number
	// of steps a contract is allowed to execute.
	ContractExec int64

	// Nonce used to generate the block,
	// if this is < 0 && > -MINER_RORATE_FREQ, the block is generated by a committee without a Miner.
	// -Nonce = the number of blocks generated by the active miner(s). This value =
	// -((-Nonce of previous + 1) % MINER_RORATE_FREQ) if Nonce of previous <= 0, or is >= 0
	// if Nonce of previous > 0.
	// if this is == - MINER_RORATE_FREQ, the block is generated by a committee with a rotation of Miner,
	// Nonce = - height (lower 31 bits) of the Miner block providing the new miner.
	// if this is > 0, this block is generated with a POW proof when the committee stales.
	// the required difficulty is the Bits in miner block of the last rotation before this
	// block.
	Nonce int32			// always present
}

// when block is generated by a committee, the coin base Tx includes payment to committee members.
// its input includes signatures of miners who signed the Tx and signature of witnesses
// witnesses will sign the block only after the block has been decided by the committee
// every MINER_RORATE_FREQ blocks, the most senior member is removed from committee and the
// fisrt miner candidate in MingingRightBlock is added to the committee (if he is not in the committee)

// when block is generated by POW, the miner alone abtains all the award, and then a new committee
// is form in the order as below (most senior frst). Upto MINER_RORATE_FREQ - 2 miners of the miners
// of immediate preceeding POW blocks, miner of this block, miner candidates in MingingRightBlock.

// blockHeaderLen is a constant that represents the number of bytes for a block
// header.
const blockHeaderLen = 84	// or 108 with Bits & IP
const minerBlockLen = 180	// max len. if IPv6 address & port

// BlockHash computes the block identifier hash for the given block header.
func (h *BlockHeader) BlockHash() chainhash.Hash {
	// Encode the header and double sha256 everything prior to the number of
	// transactions.  Ignore the error returns since there is no way the
	// encode could fail except being out of memory which would cause a
	// run-time panic.
	buf := bytes.NewBuffer(make([]byte, 0, MaxBlockHeaderPayload))
	_ = writeBlockHeader(buf, 0, h)

	return chainhash.DoubleHashH(buf.Bytes())
}

// OmcDecode decodes r using the bitcoin protocol encoding into the receiver.
// This is part of the Message interface implementation.
// See Deserialize for decoding block headers stored to disk, such as in a
// database, as opposed to decoding block headers from the wire.
func (h *BlockHeader) OmcDecode(r io.Reader, pver uint32, enc MessageEncoding) error {
	return readBlockHeader(r, pver, h)
}

// OmcEncode encodes the receiver to w using the bitcoin protocol encoding.
// This is part of the Message interface implementation.
// See Serialize for encoding block headers to be stored to disk, such as in a
// database, as opposed to encoding block headers for the wire.
func (h *BlockHeader) OmcEncode(w io.Writer, pver uint32, enc MessageEncoding) error {
	return writeBlockHeader(w, pver, h)
}

// Deserialize decodes a block header from r into the receiver using a format
// that is suitable for long-term storage such as a database while respecting
// the Version field.
func (h *BlockHeader) Deserialize(r io.Reader) error {
	// At the current time, there is no difference between the wire encoding
	// at protocol version 0 and the stable long-term storage format.  As
	// a result, make use of readBlockHeader.
	return readBlockHeader(r, 0, h)
}

// Serialize encodes a block header from r into the receiver using a format
// that is suitable for long-term storage such as a database while respecting
// the Version field.
func (h *BlockHeader) Serialize(w io.Writer) error {
	// At the current time, there is no difference between the wire encoding
	// at protocol version 0 and the stable long-term storage format.  As
	// a result, make use of writeBlockHeader.
	return writeBlockHeader(w, 0, h)
}

// NewBlockHeader returns a new BlockHeader using the provided version, previous
// block hash, merkle root hash, difficulty bits, and nonce used to generate the
// block with defaults for the remaining fields.
func NewBlockHeader(version uint32, prevHash, merkleRootHash *chainhash.Hash,
	bits uint32, nonce int32) *BlockHeader {

	// Limit the timestamp to one second precision since the protocol
	// doesn't support better.
	return &BlockHeader{
		Version:    version,
		PrevBlock:  *prevHash,
		MerkleRoot: *merkleRootHash,
		Timestamp:  time.Unix(time.Now().Unix(), 0),
		ContractExec:       0,
		Nonce:      nonce,
	}
}

// readBlockHeader reads a bitcoin block header from r.  See Deserialize for
// decoding block headers stored to disk, such as in a database, as opposed to
// decoding from the wire.
func readBlockHeader(r io.Reader, pver uint32, bh *BlockHeader) error {
	return common.ReadElements(r, &bh.Version, &bh.PrevBlock, &bh.MerkleRoot,
		(*common.Uint32Time)(&bh.Timestamp), &bh.ContractExec, &bh.Nonce)
}

// writeBlockHeader writes a bitcoin block header to w.  See Serialize for
// encoding block headers to be stored to disk, such as in a database, as
// opposed to encoding for the wire.
func writeBlockHeader(w io.Writer, pver uint32, bh *BlockHeader) error {
	sec := uint32(bh.Timestamp.Unix())
	return common.WriteElements(w, bh.Version, &bh.PrevBlock, &bh.MerkleRoot,
		sec, bh.ContractExec, bh.Nonce)
}

// BlockHash computes the block identifier hash for the given block header.
func (h *MingingRightBlock) BlockHash() chainhash.Hash {
	// Encode the header and double sha256 everything prior to the number of
	// transactions.  Ignore the error returns since there is no way the
	// encode could fail except being out of memory which would cause a
	// run-time panic.
	buf := bytes.NewBuffer(make([]byte, 0, minerBlockLen))
	_ = writeMinerBlock(buf, 0, h)

	return chainhash.DoubleHashH(buf.Bytes())
}

// OmcDecode decodes r using the bitcoin protocol encoding into the receiver.
// This is part of the Message interface implementation.
// See Deserialize for decoding block headers stored to disk, such as in a
// database, as opposed to decoding block headers from the wire.
func (h *MingingRightBlock) OmcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {
	return readMinerBlock(r, pver, h)
}

// OmcEncode encodes the receiver to w using the bitcoin protocol encoding.
// This is part of the Message interface implementation.
// See Serialize for encoding block headers to be stored to disk, such as in a
// database, as opposed to encoding block headers for the wire.
func (h *MingingRightBlock) OmcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {
	return writeMinerBlock(w, pver, h)
}

// Deserialize decodes a block header from r into the receiver using a format
// that is suitable for long-term storage such as a database while respecting
// the Version field.
func (h *MingingRightBlock) Deserialize(r io.Reader) error {
	// At the current time, there is no difference between the wire encoding
	// at protocol version 0 and the stable long-term storage format.  As
	// a result, make use of readBlockHeader.
	return readMinerBlock(r, 0, h)
}

func (h *MingingRightBlock) SerializeSize() int {
	return minerBlockLen
}

// Serialize encodes a block header from r into the receiver using a format
// that is suitable for long-term storage such as a database while respecting
// the Version field.
func (h *MingingRightBlock) Serialize(w io.Writer) error {
	// At the current time, there is no difference between the wire encoding
	// at protocol version 0 and the stable long-term storage format.  As
	// a result, make use of writeBlockHeader.
	return writeMinerBlock(w, 0, h)
}

// readBlockHeader reads a bitcoin block header from r.  See Deserialize for
// decoding block headers stored to disk, such as in a database, as opposed to
// decoding from the wire.
func readMinerBlock(r io.Reader, pver uint32, bh *MingingRightBlock) error {
	if err := common.ReadElements(r, &bh.Version, &bh.PrevBlock,
		&bh.BestBlock, (*common.Uint32Time)(&bh.Timestamp), &bh.Bits, &bh.Nonce); err != nil {
		return err
	}

	t, err := common.ReadVarBytes(r, 0, 20, "Miner")
	if err != nil {
		return err
	}
	copy(bh.Miner[:], t)
	t, err = common.ReadVarBytes(r, 0, 80, "Connection")
	if err != nil {
		return err
	}
	bh.Connection = t

	d, err := common.ReadVarInt(r, 0)
	if err != nil || d == 0 {
		return nil
	}
	bh.Utxos = &OutPoint{}
	if err = readOutPoint(r, 0, 0, bh.Utxos); err != nil {
		return err
	}

	d, err = common.ReadVarInt(r, 0)
	if err != nil {
		return nil
	}
	bh.ViolationReport = make([]*Violations, d)

	for i := 0; i < int(d); i++ {
		bh.ViolationReport[i] = &Violations{}
		if err := bh.ViolationReport[i].Read(r); err != nil {
			return err
		}
	}

	if bh.Version >= Version2 {
		if d, err := common.ReadVarInt(r, 0); err != nil {
			return err
		} else {
			bh.Collateral = uint32(d)
		}
		if d, err := common.ReadVarInt(r, 0); err != nil {
			return err
		} else {
			bh.MeanTPH = uint32(d)
		}

		d, err = common.ReadVarInt(r, 0)
		if err != nil {
			return err
		}

		bh.TphReports = make([]uint32, d)

		for i := 0; i < int(d); i++ {
			t, err := common.ReadVarInt(r, 0)
			if err != nil {
				return err
			}
			bh.TphReports[i] = uint32(t)
		}
		if err := common.ReadElements(r, &bh.ContractLimit); err != nil {
			bh.ContractLimit = 0
		}
	}

	return nil
}

// writeBlockHeader writes a miner block to w.  See Serialize for
// encoding block headers to be stored to disk, such as in a database, as
// opposed to encoding for the wire.
func writeMinerBlock(w io.Writer, pver uint32, bh *MingingRightBlock) error {
	sec := uint32(bh.Timestamp.Unix())

	if err := common.WriteElements(w, bh.Version, &bh.PrevBlock,
		bh.BestBlock, sec, bh.Bits, bh.Nonce); err != nil {
		return err
	}

	if err := common.WriteVarBytes(w, 0, bh.Miner[:]); err != nil {
		return err
	}
	if err := common.WriteVarBytes(w, 0, bh.Connection); err != nil {
		return err
	}

	nu := 0
	if bh.Utxos != nil {
		nu = 1
	}

	if err := common.WriteVarInt(w, 0, uint64(nu)); err != nil {
		return err
	}
	if bh.Utxos != nil {
		if err := writeOutPoint(w, 0, 0, bh.Utxos); err != nil {
			return err
		}
	}

	if err := common.WriteVarInt(w, 0, uint64(len(bh.ViolationReport))); err != nil {
		return err
	}
	for _, p := range bh.ViolationReport {
		if err := p.Write(w); err != nil {
			return err
		}
	}

	if bh.Version >= Version2 {	// TphReports activated
		if err := common.WriteVarInt(w, 0, uint64(bh.Collateral)); err != nil {
			return err
		}
		if err := common.WriteVarInt(w, 0, uint64(bh.MeanTPH)); err != nil {
			return err
		}

		// for compatibility with old structure, we should not write a '0' when report
		// length is 0 for it would change block hash
		if err := common.WriteVarInt(w, 0, uint64(len(bh.TphReports))); err != nil {
			return err
		}
		for _, p := range bh.TphReports {
			if err := common.WriteVarInt(w, 0, uint64(p)); err != nil {
				return err
			}
		}
		if err := common.WriteElement(w, bh.ContractLimit); err != nil {
				return err
			}
	}

	return nil
}

type MinerBlock struct {		// equivalent of btcutil.Block
	msgBlock *MingingRightBlock
	serializedBlock          []byte          // Serialized bytes for the block
	height int32
	hash * chainhash.Hash
}

func NewMinerBlockFromBlockAndBytes(msgBlock *MingingRightBlock, serializedBlock []byte) *MinerBlock {
	return &MinerBlock{
		msgBlock:        msgBlock,
		serializedBlock: serializedBlock,
		height:     -1,
	}
}

func (b * MinerBlock) MsgBlock() *MingingRightBlock {
	return b.msgBlock
}

func (b * MinerBlock) Hash() * chainhash.Hash {
	if b.hash != nil {
		return b.hash
	}

	h := b.msgBlock.BlockHash()
	b.hash = &h

	return b.hash
}

func (b * MinerBlock) SetHeight(h int32) {
	b.height = h
}

func (b *MinerBlock) Height() int32 {
	return b.height
}

// Bytes returns the serialized bytes for the Block.  This is equivalent to
// calling Serialize on the underlying wire.MsgBlock, however it caches the
// result so subsequent calls are more efficient.
func (b *MinerBlock) Bytes() ([]byte, error) {
	// Return the cached serialized bytes if it has already been generated.
	if len(b.serializedBlock) != 0 {
		return b.serializedBlock, nil
	}

	// Serialize the MsgBlock.
	w := bytes.NewBuffer(make([]byte, 0, b.msgBlock.SerializeSize()))
	err := b.msgBlock.Serialize(w)
	if err != nil {
		return nil, err
	}
	serializedBlock := w.Bytes()

	// Cache the serialized bytes and return them.
	b.serializedBlock = serializedBlock
	return serializedBlock, nil
}

func NewMinerBlock(b *MingingRightBlock) * MinerBlock {
	return &MinerBlock { b, nil,int32(-1),nil }
}

func (msg *MingingRightBlock) Command() string {
	return CmdMinerBlock
}

// MaxPayloadLength returns the maximum length the payload can be for the
// receiver. This is part of the Message interface implementation.
func (msg *MingingRightBlock) MaxPayloadLength(pver uint32) uint32 {
	// Block header at 80 bytes + transaction count + max transactions
	// which can vary up to the MaxBlockPayload (including the block header
	// and transaction count).
	return MaxMinerBlockHeaderPayload
}
